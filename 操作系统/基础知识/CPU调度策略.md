# CPU调度策略  


## 调度的基本想法  

1.FIFO  
* 简单有效   但是短作业是不是可以适当优先

2.Priority  

* 短任务适当优先，但任务占用的资源越来越多怎么办，可能需要再适当降低它的优先级

![image](https://user-images.githubusercontent.com/58176267/158096929-0810ffee-f66e-4676-86ec-24e107947e0c.png)


## 调度算法的评价指标  

* 尽快结束任务 ： 周转时间(从任务开始到结束)短
* 用户操作响应快 ： 响应时间(从操作发生到响应)短  
* 系统内耗时间少 ： 吞吐量(完成的任务量)  

**问题**  

* 吞吐量和响应是按有矛盾  
  * 响应时间小————>切换次数多————>系统内耗大————>吞吐量小  
* 前台任务和后台任务的关注点不同  
  * 前台任务关注响应时间  后台任务关注周转时间    响应时间小就要进程的切换次数多，但切换也是需要时间的，比如TSS，LDT(内存映射表)，栈等要切换，这都是系统内耗，切换频繁了系统内耗就大，吞吐量就小(实际给用户干活的时间少了)  
* IO约束型任务(如含read的)和CPU约束型任务(如gcc编译程序时)有各自的特点   
*    
**因此，调度系统需要做到折中，平衡，综合考虑，同时调度算法如果特别复杂会让操作系统变得复杂，内耗可能变大， 但有效的系统需要高效，需要调度算法尽量简单**    

IO约束型进程优先级高点，这样IO就能先执行起来，然后切换到CPU约束型任务执行，两者就能并行起来  

IO约束型任务往往对应的就是前台任务(和用户进行交互的)，前台任务优先级高一点，后台任务用户相对不是那么关心  


## 常见的调度算法  


1 FCFS （First Come First Served）   

假设所有进程都在就绪态等待，下面例子，每一个进程的周转时间分别为 10 39 42 49 61  所以平均周转时间是相加除以5
将其中一个短作业提前后，会发现平均周转时间变短，因此这种先来先服务的简单策略不实用  

![image](https://user-images.githubusercontent.com/58176267/158099624-1162bd02-7e03-4b98-9171-8c5040e770a2.png)


2 SJF : 短作业优先  

**可以证明，将短作业放前面，平均周转时间最短，因此这可以在后面的调度策略中融合进去**      

![image](https://user-images.githubusercontent.com/58176267/158100150-3825d024-ea59-46b4-90f1-b9cbe2a11d35.png)


3.响应时间方面  

单纯按照上面的短作业优先，无法保证响应时间，如P2表示用户某个操作，从0时刻开始的，等到前面四个进程响应完才到P2，P2等待时间太长，当然，如果换谁在后面，响应时间也太长；  

因此，可**按时间片轮转调度**











