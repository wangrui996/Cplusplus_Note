# 操作系统内存管理  


##  内存碎片  

**外部碎片**：在分配单元间的未使用的内存  
**内存碎片**：在分配单元内的未使用的内存  

## 内存管理方法  
* 当一个程序准许运行在内存中时，分配一个连续的区间  
* 分配一个连续的内存区间给运行的程序以访问数据  

### 分配策略  
* 首次适配  
* 最优适配  
* 最差适配  

#### 首次适配算法/第一匹配分配  
为了分配n字节，使用第一个可用的空闲块以致块的尺寸比n大  

**基本原理&实现*  

**需求**  
* 按地址排序的空闲块的列表  
* 分配需要寻找一个合适的分区  
* 重分配需要检查，看是否自由分区能合并于相邻的空闲分区（如果有的话）  

**优势**  
* 简单  
* 易于产生更大空闲块（如果前面已经找到合适的空闲块，就不需要破坏后面可能存在的更大的空闲块）

**劣势**  
* 容易产生外部碎片  第一次找到一个空闲块，并没有全部利用，下一次可能找到的是下一个空闲块，因为上一个空间可能不够了  
* 不确定性


#### 最优适配  
* 为了分配n个字节，使用最小的可用空闲块，以致块的尺寸比n大  

**基本原理&实现**  

* 为了避免分割大空闲块
* 为了最小化外部碎片产生的尺寸  

**需求**  
* 按尺寸排列的空闲块列表（最好是能按照空闲块的大小排序）  
* 分配需要寻找一个合适的分区
* 重分配需要搜索及合并于相邻的空闲分区（如果有的话） 

**优势**  
* 当大部分分配是小尺寸时非常有效（避免大的空闲块被拆分）  
* 比较简单  

**劣势**  
* 外部碎片：每次都找最小的适合的内存块，这些内存块被使用一部分后剩下的空间就很小了，这部分外部碎片再被利用的可能性很小，所以可能出现很好小的碎片   
* 重分配慢  
* 易产生很多没用的微小碎片  

#### 最差适配  
* 为了分配n个字节，使用最大的可用空闲块，以致块的尺寸比n大  
目的：为了避免有太多微小的碎片  
特点是将大块给拆分了，尽可能的保留的小的块（可以认为是好处也可以认为是坏处）  

**基本原理&实现**  

**需求**  
* 按尺寸排列的空闲块列表
* 分配很快（获得最大的分区）  
* 重分配需要合并相邻的空闲分区（如果有的话），然后调整空闲块列表（按size排序）  

**优势**  
* 加入分配是中等尺寸效果最好  

**劣势**  
* 重分配慢  
* 外部碎片  
* 易于破碎大的空闲块以致大分区无法被分配  






















