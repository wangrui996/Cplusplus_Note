# 系统调用的实现  

**操作系统在内存中执行，用户的应用程序也在内存中执行，当用户想访问操作系统提供的某个功能时，是不能直接跳到操作系统具有相应功能的那段内存中，如用jmp，mov，为什么？**  

**原因：将内核程序和用户程序隔离！**

不能随意调用操作系统数据，随意jmp，因为操作系统中保存着很多重要数据，如root密码，如果一个应用程序能随意访问操作系统中的数据，这个root密码就可能被获取

**内核态和用户态**：一种处理器的“硬件设计”————特权环 ，**用户态**对应的是内存中的**用户段**， **内核态**对应的是内存中的**内核段**  
* 内核态可以访问任何数据，用户态不能访问内核数据
* 对于跳转指令也一暗影实现了隔离

由于CS:IP是当前指令，用CS最低两位来表示：0 是内核态  3是用户态

DPL(目标段的特权级)：系统初始化时被初始化为0 

如执行一个用户的main程序，PC指向main函数，PC由CS和IP组成，此时CS表示main函数在内存中的区域，CS中的某部分就表示了它的特权级；
每一次访问时，要比较检查当前特权级CPL和目标特权级DPL，只有CPL<=DPL,这条指令才被允许（硬件检查？）












系统调用需要提供一种能够进入内核的手段  





