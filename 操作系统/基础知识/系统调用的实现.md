# 系统调用的实现  

**操作系统在内存中执行，用户的应用程序也在内存中执行，当用户想访问操作系统提供的某个功能时，是不能直接跳到操作系统具有相应功能的那段内存中，如用jmp，mov，为什么？**  

## 原因  
 
**原因：将内核程序和用户程序隔离！**

不能随意调用操作系统数据，随意jmp，因为操作系统中保存着很多重要数据，如root密码，如果一个应用程序能随意访问操作系统中的数据，这个root密码就可能被获取

## 怎样实现  

**内核态和用户态**：一种处理器的“硬件设计”————特权环 ，**用户态**对应的是内存中的**用户段**， **内核态**对应的是内存中的**内核段**  
* 内核态可以访问任何数据，用户态不能访问内核数据
* 对于跳转指令也一样实现了隔离

由于CS:IP是当前指令，用CS最低两位来表示：0 是内核态  3是用户态

每一次访问时，要比较检查当前特权级CPL和目标特权级DPL，只有CPL<=DPL,这条指令才被允许（硬件检查）

* **在系统初始化时，head.s执行的时候，会针对内核态的代码和数据建立GDT表，其对应的GDT表的项的DPL就等于0**  
* **系统初始化完成后进入用户态后，当执行一个用户的main程序时，PC指向main函数，PC由CS和IP组成，此时CS表示main函数在内存中的区域，CS中的某部分就表示了它的特权级，其值为3；实际上是在初始化结束进入进入用户态（启动shell）前，将CS的CPL置为3**  

## 硬件提供了主动进入内核的方法————中断  

对于intel X86，就是中断指令int  

* int指令将使CS中的CPL改成0，“进入内核”  
* 这是用户程序发起的调用内核代码的唯一方式  

* 系统调用的核心：  
    * (1)**用户程序**中包含一段包含**int指令**的代码
        * 对于上层应用程序，需要有含中断的代码，由库函数来做 
    * (2)**操作系统**写**中断处理**，获取想调用程序的编号
    * (3)**操作系统**根据编号**执行相应代码**  

## 系统调用背后的故事——核心原理

**以open()函数为例：因为想要利用这个函数进入操作系统内核，因为上面的原因，它实际上要变成一段含有int的程序————>而要想实现，操作系统还必须提供对应的中断处理函数————>在中断处理函数中，根据是open还是read等，再跳到相应位置执行**  

**操作系统初始化时设定了，只能通过int 0x80 进入内核**

系统调用需要提供一种能够进入内核的手段  

## 用户程序到最后执行发生了什么  

调用printf(...)/应用程序————>库函数printf(...)/库函数————>库函数write(...)————>

因为用户程序中调用printf(...)格式是里面包含了要打印的字符串等等，而write(...)需要好几个参数（源码在linux/lib/write.c）,所以C库函数需要做个转换，


