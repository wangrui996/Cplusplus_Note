# 用户级线程  


## 线程的引入  

**进程 = 资源 + 指令执行序列**  

其中**资源表示映射表(内存资源)**，那么多进程切换时，能否只切换指令序列变换，而资源不变换？  
* 将资源和指令执行分来  
* 一个资源+多个指令执行序列  

### 线程  

在一个资源下，启动了多个轻巧的指令序列，这个指令序列可以来回切，而且切换的时候只切换指令序列不需要动资源，既然也是指令序列在来回切，而且和进程不同(不需要特别复杂)，就叫**线程**

* **保留了并发的优点，避免了进程切换代价**  
* 进程的切换可以分成两部分，指令切换+映射表切换(内存管理部分)  
* 线程的切换可以只关注指令的切换  

![image](https://user-images.githubusercontent.com/58176267/156487067-cb07e0f7-bbcd-4587-8a2d-9dcce081df1a.png)


#### 线程的价值 即 多个指令序列 + 一个地址空间是否实用  

* 一个网页浏览器  
    * 一个线程用来从服务器接收数据  
    * 一个线程用来显示图片  
    * 一个线程用来出来图片(如解压缩)  
    * 一个线程用来显示图片  

* 上面这些如果变成顺序执行，就需要先下载数据，等所有数据下载完，再调用另外一段程序来显示文本，执行完以后，再调用另外一段程序显示图片  
* 因此这些**线程需要共享资源**
    * 接收数据放在内存100处，需要显示时从该处读  
    * 所有的文本、图片都显示在一个屏幕上  
* 合理的顺序是：启动一段程序，接收数据，启动一段程序显示文本，另一段程序显示图片，这些程序序列交替执行  
* 这样的例子为什么不是**进程**是而叫**线程**：因为指令序列1需要从服务器拿到数据放在缓冲区, 另一个指令序列需要从缓冲区拿数据来显示，如果两个指令序列用的不是同一个映射，就需要从放数据的缓冲区拷贝数据到自己读数据的缓冲区太费劲，本身就需要共享缓冲区，共享资源，没必要分开  


#### 怎么实现线程  

注意：只是同时让两个指令序列开始执行不叫并发，还需要两指令序列交替执行  

![image](https://user-images.githubusercontent.com/58176267/156489305-3418c7b4-7bbc-4503-b48d-301da8181ca9.png)


上面的例子中，create函数，就能让他们同时出发  
Yield函数，能让他们交替执行,程序A执行过程中通过Yield函数切出去  


