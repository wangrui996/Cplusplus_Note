# 内核级线程代码实现  




  
## switch_to  

在linux 0.11中没有用内核栈(kernal stack)实现，而是用的TSS(task struct segment 任务结构段)，也就是段任务切换  

* 这里的TR是CPU固有的寄存器，相当于存储着任务信息的地址  
* 当需要进程核心级线程切换时,将TR指向第二个线程描述符(GDT表中)  
* 根据TR的值, 通过GDT表中拿到新的任务(线程段)的信息，这个**新的任务的信息包括CPU所有寄存器的信息**   

![image](https://user-images.githubusercontent.com/58176267/157384443-e7ec0b59-a307-4917-a548-cc56895b9030.png)  

上面的过程的解释：  
ljmp长跳转指令 ：   
* 先将当前CPU的所有寄存器放在当前TR指向的段中(它指向的段是通过查GDT表找到的)(现在的TR还代表当前执行的任务信息)  
* 因为调度算法得到了下一个任务选择子n并传入了switch_to     根据TSS(n)找到新的段
* 将新的任务段中信息赋值给CPU各寄存器  
* 上面CPU寄存器包括了栈寄存器ESP，栈也会切换过来  与TCB配合**栈**方式的相比多拷贝了很多寄存器内容(在一条长跳转指令中)  


**所以上述方法也能实现内核级线程五段论的过程，其中核心代码是int、switch_to函数中的ljmp、iret   操作系统核心的地方在linux0.11中就是包含了他们的总共几十行代码   

将上面的过程修改为基于栈的方式切换代码量也不会太多重要的是细节的处理  


## ThreadCreate  

理解了线程的切换，创建一个线程就是把它变成可以切换的样子，如果是上面的tss方式，重点是把TSS做好  

做好TSS，首先要有PCB（线程控制块）  

![image](https://user-images.githubusercontent.com/58176267/157389539-6bd33506-d7bb-4924-b94d-311aaafeb7e1.png)


* 1._sys_fork函数中，有个_copy_process  也就是父进程(创建新的进程的那个进程)在创建子进程时，先要在内核栈压入很多内容，主要是父进程在用户态执行时的"样子"，这些内容要传递给子进程，通过_copy_process   

* 2. 图中代码_copy_process函数的参数都没有值，因为_sys_fork函数是一段汇编代码，在里面调用了C函数，那么这个C函数的所有参数完全取自栈，而要取的这些参数实际上已经在栈中了(1中解释过)  
* 3. C函数的参数中，最后面的参数来自栈底，也就是函数参数从栈中取参数时是，栈顶参数先给第一个参数，依次赋值  
* 4.上图代码中，在栈中EFLAGS下面的ret=??1  代表的是，int 0x80 执行完之后的地址(因为创建进程时，int 0x80一执行，就会把SS,SP,EFLAGS,ret等压入了栈)  





