# 核心级线程  

* **内核级线程的ThreadCreate是系统调用，会进入内核，内核知道TCB  Yiled()用户不可见，调度点由系统决定**

* 进程只有内核级进程，因为进程要分配资源，要访问内存，可能还要访问文件等，必须要内核态才能控制这些资源
* 进程的切换实际上要理解好内核级线程的切换和资源的切换  

## 多核与多CPU的区别  

* 多CPU(处理器)：每个CPU有自己的一套缓存(Cache)，有自己的一套MMU(内存映射)
* 多核：多cpu用的是一套缓存和内存映射  **多个执行序列用一套映射，就是线程； 多个线程可以通过内核分配到不同的cpu核上，而且用的是同一套映射，所以多个线程只有到内核中去，才能充分的利用多个核** 
* 如果是用户级线程，操作系统是看不到的，无法为他们分配硬件
* 所谓充分发挥多核的特性，是让他们**并行**，其中其中执行的时候另一个也执行； 与**并发**的区别：**并发是同时出发，交替执行**



## 核心级线程  

* ThreadCreate是系统调用，内核管理TCB，内核负责切换线程

### 内核栈、TCB  

* 用户栈是否还要用？ 因为执行的代码仍然在用户态，还要进行函数调用，要有用户栈
* 也要在核心态跑，所以也要有核心栈  
* 内核级线程与用户级线程的本质区别：就是一个栈到一套栈，两个栈到两套栈  **用户级线程中两个线程需要两个栈，内核级线程中两个线程要两套栈**  

* **TCB应该关联一套栈，且在内核中，切换TCB时要切换两套栈，由一个内核栈切换到另一个内核栈，用户栈也跟着从一个用户栈切换到另一个用户栈**

### 用户栈和内核站之间的关联  

什么时候会有内核栈，显然是进入内核的时候因为进入内核后也会有c语言函数调用； 那么什么时候会进入内核？，进入内核的唯一方法是 **中断**(可能是代码中int指令，或者是硬件如鼠标，时钟中断)  

* 一旦通过int指令进入内核，操作系统会通过一些硬件的寄存器找到这个线程对应的内核栈，还要压入一些东西包括在用户态执行的栈，和刚才的PC，CS(记录用户态执行到什么地方了)

理解下图，就是在用户态进入内核态的时候(**发生中断的时候**)，**通过向内核栈**(操作系统根据计算机硬件寄存器找到的该线程对应的内核栈)**压入用户栈(栈顶和栈底地址)，用户态执行代码的PC等，实现了内核栈和用户栈的关联**，在IRET即中断返回时，弹出刚才的东西，就会回到用户态刚才执行的地方  

![image](https://user-images.githubusercontent.com/58176267/156908629-d784e69a-3017-483f-a535-75550148aba2.png)

