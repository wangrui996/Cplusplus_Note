# 静态库和动态库  

**补充** ： 
* 编译阶段的报错一般是语法错误，报错信息会给出行号    链接阶段针对是二进制文件，因此报错没有了行号信息，另外报错信息中如果有“collect”字样，是链接器  
* 编译程序过程中发现一个函数调用，会找它的定义或声明，如果在调用前出现了定义或者声明即可通过编译  
    * 两者都没有时，编译器会帮忙做隐式声明，而编译器只会做一种隐式声明返回值类型为int，函数名和调用的函数名一致，参数会根据调用的函数中参数类型一致 ，如果这个函数返回值刚好是int，编译器只会报警告  
    * 如果函数的返回值返回值类型不是int而是void等，编译器声明会失败报错  

* 为了解决上面的问题，规范的写法就是调用之前显式的声明  但如果用的是库中的函数，最好将声明写在与库文件相匹配的头文件中 

**头文件守卫：防止头文件被重复包含**
```cpp
#ifndef _HEAD_H_
#define _HEAD_H_
......
#endif
```
假设头文件名为head.h 在某源文件include了很多次head.d  

预处理时，第一次碰到#include "head.h"  发现head.d中 #ifndef _HEAD_H_ 成立，此时就define一下，然后加入里面的内容   第二次碰到时，#ifndef _HEAD_H_ 不成立，下面的不会展开  

## 静态库  

静态库：在可执行程序运行前就已经加入到执行码中，成为程序的一部分

静态库的加载，将库文件作为a.out   b.out   c.out的一部分， 库文件需要和源程序一起编译到可执行程序中

![image](https://user-images.githubusercontent.com/58176267/158407948-60743ab5-a949-4e31-93bc-8e939d4bb6f4.png)


## 动态库  

动态库：程序运行时，调用库函数时加载库函数对应的代码执行  

![image](https://user-images.githubusercontent.com/58176267/158409479-f229e2f5-4e11-4784-9543-190a2ba8b290.png)


* 将库文件加载到内存中，可执行程序a.out  b.oit  c.out也在内存中，当他们使用库的直接用，应用程序贡献它里面的内容，所以叫**共享库**    
* 动态库不需要编译到源文件中，在源文件如果用到了共享库，如有一个函数调用，该函数会动态地进入贡献库中某段内存执行一段指令，也就是，只有执行到调用库函数的那一行，才会动态地加载动态库中内容到程序中  


## 区别  

* 静态库会将库文件添加到源程序中一起编译，执行的时候，调用源文件内的函数和调用库函数没有区别，速度也一样  
* 动态库是共享的机制，这个库本身不存在于自己的程序中，当程序执行到调用库函数时，动态调用，将库函数加载进来执行，此时，使用库函数要慢与自己的函数  

## 静态库与动态库应用  

静态库：对时间要求较高，但对空间要求比较低的核心程序中  
动态库： 对时间要求较低，对空间要求比较高

一般情况下都是使用制作并使用动态库

##  静态库制作及使用　　

库名要使用lib开头，后缀为.a

### 静态库制作  
1. 将 .c 生成 .o 文件  （预处理编译汇编，得到.o目标文件）  
gcc -c add.c -o add.o  

2. 使用 ar 工具制作静态库  
ar rcs libxxx.a add.o sub.o div.o  

### 静态库使用

编译静态库到可执行文件中  
gcc test.c libxxx.a -o a.out   
相当于将这些一起编译  


## 动态库  

动态库制作及使用：
1. 将 .c 生成 .o 文件， （生成与位置无关的代码 -fPIC）
gcc -c add.c -o add.o -fPIC
2. 使用 gcc -shared 制作动态库
gcc -shared -o lib 库名.so add.o sub.o div.o
3. 编译可执行程序时，指定所使用的动态库。 -l：指定库名(去掉 lib 前缀和.so 后缀) -L：
指定库路径。
gcc test.c -o a.out -lmymath -L./lib
4. 运行可以执行程序 ./a.out 出错！！！！ --- ldd a.out --> "not found"
error while loading shared libraries: libxxx.so: cannot open shared object file: 
No such file or directory
原因：
链接器： 工作于链接阶段， 工作时需要 -l 和 -L
动态链接器： 工作于程序运行阶段，工作时需要提供动态库所在目录位置。
解决方式：
【1】 通过环境变量： export LD_LIBRARY_PATH=动态库路径
./a.out 成功！！！ （临时生效， 终端重启环境变量失效）
【2】 永久生效： 写入 终端配置文件。 .bashrc 建议使用绝对路径。
1) vi ~/.bashrc
2) 写入 export LD_LIBRARY_PATH=动态库路径 保存
3）. .bashrc/ source .bashrc / 重启 终端 ---> 让修改后的.bashrc 生效
4）./a.out 成功！！！
【3】 拷贝自定义动态库 到 /lib (标准 C 库所在目录位置)
【4】 配置文件法
1）sudo vi /etc/ld.so.conf
2) 写入 动态库绝对路径 保存
3）sudo ldconfig -v 使配置文件生效。
4）./a.out 成功！！！--- 使用 ldd a.out 查看






